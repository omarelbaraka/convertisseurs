le nom est : marcu_statistics_sentence_pass_one.pdf

le titre est : Statistics-Based Summarization — Step One: Sentence Compression


les auteur sont :                                            Kevin Knight and Daniel Marcu 

Abstract When humans produce summaries of documents, they do not simply extract sentences and concatenate them. Rather, they create new sentences that are grammatical, that cohere with one another, and that capture the most salient pieces of information in the original document. Given that large collections of text/abstract pairs are available online, it is now possible to envision algorithms that are trained to mimic this process. In this paper, we focus on sentence compression, a simpler version of this larger challenge. We aim to achieve two goals simultaneously: our compressions should be grammatical, and they should retain the most important pieces of information. These two goals can conﬂict. We devise both noisy-channel and decision-tree approaches to the problem, and we evaluate results against manual compressions and a simple baseline.  

l introduction est : Introduction Most of the research in automatic summarization has focused on extraction, i.e., on identifying the most important clauses/sentences/paragraphs in texts (see (Mani & Maybury 1999) for a representative col- lection of papers). However, determining the most im- portant textual segments is only half of what a summa- rization system needs to do because, in most cases, the simple catenation of textual segments does not yield coherent outputs. Recently, a number of researchers have started to address the problem of generating co- herent summaries: McKeown et al. (1999), Barzilay et al. (1999), and Jing and McKeown (1999) in the context of multidocument summarization; Mani et al. (1999) in the context of revising single document extracts; and Witbrock and Mittal (1999) in the context of headline generation. The approach proposed by Witbrock and Mit- tal (1999) is the only one that applies a probabilistic model trained directly on Headline, Document pairs. However, this model has yet to scale up to generat- ing multiple-sentence abstracts as well as well-formed, grammatical sentences. All other approaches employ sets of manually written or semi-automatically derived Copyright c  2000, American Association for Artiﬁcial In- telligence (www.aaai.org). All rights reserved. rules for deleting information that is redundant, com- pressing long sentences into shorter ones, aggregating sentences, repairing reference links, etc. Our goal is also to generate coherent abstracts. How- ever, in contrast with the above work, we intend to eventually use Abstract, Text tuples, which are widely available, in order to automatically learn how to rewrite Texts as coherent Abstracts. In the spirit of the work in the statistical MT community, which is focused on sentence-to-sentence translations, we also decided to fo- cus ﬁrst on a simpler problem, that of sentence compres- sion. We chose this problem for two reasons: • First, the problem is complex enough to require the development of sophisticated compression models: Determining what is important in a sentence and determining how to convey the important informa- tion grammatically, using only a few words, is just a scaled down version of the text summarization prob- lem. Yet, the problem is simple enough, since we do not have to worry yet about discourse related issues, such as coherence, anaphors, etc. • Second, an adequate solution to this problem has an immediate impact on several applications. For example, due to time and space constraints, the generation of TV captions often requires only the most important parts of sentences to be shown on a screen (Linke-Ellis 1999; Robert-Ribes et al. 1999). A good sentence compression module would there- fore have an impact on the task of automatic cap- tion generation. A sentence compression module can also be used to provide audio scanning ser- vices for the blind (Grefenstette 1998). In gen- eral, since all systems aimed at producing coher- ent abstracts implement manually written sets of sentence compression rules (McKeown et al. 1999; Mani, Gates, & Bloedorn 1999; Barzilay, McKeown, & Elhadad 1999), it is likely that a good sentence compression module would impact the overall quality of these systems as well. This becomes particularly important for text genres that use long sentences. In this paper, we present two approaches to the sen- tence compression problem. Both take as input a se- quence of words W = w1, w2, . . . , wn (one sentence). From: AAAI-00 Proceedings. Copyright © 2000, AAAI (www.aaai.org). All rights reserved. An algorithm may drop any subset of these words. The words that remain (order unchanged) form a compres- sion. There are 2n compressions to choose from—some are reasonable, most are not. Our ﬁrst approach de- velops a probabilistic noisy-channel model for sentence compression. The second approach develops a decision- based, deterministic model. A noisy-channel model for sentence compression This section describes a probabilistic approach to the compression problem. In particular, we adopt the noisy channel framework that has been relatively successful in a number of other NLP applications, including speech recognition (Jelinek 1997), machine translation (Brown et al. 1993), part-of-speech tagging (Church 1988), transliteration (Knight & Graehl 1998), and informa- tion retrieval (Berger & Laﬀerty 1999). In this framework, we look at a long string and imag- ine that (1) it was originally a short string, and then (2) someone added some additional, optional text to it. Compression is a matter of identifying the original short string. It is not critical whether or not the “original” string is real or hypothetical. For example, in statistical machine translation, we look at a French string and say, “This was originally English, but someone added ‘noise’ to it.” The French may or may not have been translated from English originally, but by removing the noise, we can hypothesize an English source—and thereby trans- late the string. In the case of compression, the noise consists of optional text material that pads out the core signal. For the larger case of text summarization, it may be useful to imagine a scenario in which a news editor composes a short document, hands it to a reporter, and tells the reporter to “ﬂesh it out” . . . which results in the article we read in the newspaper. As summarizers, we may not have access to the editor’s original version (which may or may not exist), but we can guess at it— which is where probabilities come in. As in any noisy channel application, we must solve three problems: • Source model. We must assign to every string s a probability P(s), which gives the chance that s is gen- erated as an “original short string” in the above hy- pothetical process. For example, we may want P(s) to be very low if s is ungrammatical. • Channel model. We assign to every pair of strings s, t a probability P(t | s), which gives the chance that when the short string s is expanded, the result is the long string t. For example, if t is the same as s except for the extra word “not,” then we may want P(t | s) to be very low. The word “not” is not optional, additional material. • Decoder. When we observe a long string t, we search for the short string s that maximizes P(s | t). This is equivalent to searching for the s that maximizes P(s) · P(t | s). It is advantageous to break the problem down this way, as it decouples the somewhat independent goals of creating a short text that (1) looks grammatical, and (2) preserves important information. It is easier to build a channel model that focuses exclusively on the latter, without having to worry about the former. That is, we can specify that a certain substring may represent unimportant information, but we do not need to worry that deleting it will result in an ungrammatical struc- ture. We leave that to the source model, which worries exclusively about well-formedness. In fact, we can make use of extensive prior work in source language modeling for speech recognition, machine translation, and natu- ral language generation. The same goes for actual com- pression (“decoding” in noisy-channel jargon)—we can re-use generic software packages to solve problems in all these application domains. Statistical Models In the experiments we report here, we build very sim- ple source and channel models. In a departure from the above discussion and from previous work on statis- tical channel models, we assign probabilities Ptree(s) and Pexpand tree(t | s) to trees rather than strings. In decoding a new string, we ﬁrst parse it into a large tree t (using Collins’ parser (1997)), and we then hypothesize and rank various small trees. Good source strings are ones that have both (1) a normal-looking parse tree, and (2) normal-looking word pairs. Ptree(s) is a combination of a standard proba- bilistic context-free grammar (PCFG) score, which is computed over the grammar rules that yielded the tree s, and a standard word-bigram score, which is com- puted over the leaves of the tree. For example, the tree s =(S (NP John) (VP (VB saw) (NP Mary))) is assigned a score based on these factors: Ptree(s) = P(TOP → S | TOP) · P(S → NP VP | S) · P(NP → John | NP) · P(VP → VB NP | VP) · P(VP → saw | VB) · P(NP → Mary | NP) · P(John | EOS) · P(saw | John) · P(Mary | saw) · P(EOS | Mary) Our stochastic channel model performs minimal op- erations on a small tree s to create a larger tree t. For each internal node in s, we probabilistically choose an expansion template based on the labels of the node and its children. For example, when processing the S node in the tree above, we may wish to add a prepositional phrase as a third child. We do this with probability P(S → NP VP PP | S → NP VP). Or we may choose to leave it alone, with probability P(S → NP VP | S → NP VP). After we choose an expansion template, then for each new child node introduced (if any), we grow a new subtree rooted at that node—for example (PP (P in) (NP Pittsburgh)). Any particular subtree is grown with probability given by its PCFG factorization, as above (no bigrams). G H A C a b B Q R D e C b D e D e K b d Z c (t) G H a A F G H a (s1) (s2) Figure 1: Examples of parse trees. Example In this section, we show how to tell whether one poten- tial compression is more likely than another, according to the statistical models described above. Suppose we observe the tree t in Figure 1, which spans the string abcde. Consider the compression s1, which is shown in the same ﬁgure. We compute the factors Ptree(s1) and Pexpand tree(t | s1). Breaking this down further, the source PCFG and word-bigram factors, which describe Ptree(s1), are: P(TOP → G | TOP) P(H → a | H) P(G → H A | G) P(C → b | C) P(A → C D | A) P(D → e | D) P(a | EOS) P(e | b) P(b | a) P(EOS | e) The channel expansion-template factors and the chan- nel PCFG (new tree growth) factors, which describe Pexpand tree(t | s1), are: P(G → H A | G → H A) P(A → C B D | A → C D) P(B → Q R | B) P(Z → c | Z) P(Q → Z | Q) P(R → d | R) A diﬀerent compression will be scored with a diﬀerent set of factors. For example, consider a compression of t that leaves t completely untouched. In that case, the source costs Ptree(t) are: P(TOP → G | TOP) P(H → a | H) P(a | EOS) P(G → H A | G) P(C → b | C) P(b | a) P(A → C D | A) P(Z → c | Z) P(c | b) P(B → Q R | B) P(R → d | R) P(d | c) P(Q → Z | Q) P(D → e | D) P(e | d) P(EOS | e) The channel costs Pexpand tree(t | t) are: The documentation is typical of Epson quality: excellent. Documentation is excellent. All of our design goals were achieved and the delivered performance matches the speed of the underlying device. All design goals were achieved. Reach’s E-mail product, MailMan, is a message- manage- ment system designed initially for VINES LANs that will eventually be operating system-independent. MailMan will eventually be operating system-independent. Although the modules themselves may be physically and/or electrically incompatible, the cable-speciﬁc jacks on them provide industry-standard connections. Cable-speciﬁc jacks provide industry-standard connections. Ingres/Star prices start at ,100. Ingres/Star prices start at ,100. Figure 2: Examples from our parallel corpus. P(G → H A | G → H A) P(A → C B D | A → C B D) P(B → Q R | B → Q R) P(Q → Z | Q → Z) Now we can simply compare Pexpand tree(s1 | t) = Ptree(s1) · Pexpand tree(t | s1))/Ptree(t) ver- sus Pexpand tree(t | t) = Ptree(t) · Pexpand tree(t | t))/Ptree(t) and select the more likely one. Note that Ptree(t) and all the PCFG factors can be canceled out, as they appear in any potential compression. Therefore, we need only compare compressions of the basis of the expansion-template probabilities and the word-bigram probabilities. The quantities that diﬀer between the two proposed compressions are boxed above. There- fore, s1 will be preferred over t if and only if: P(e | b) · P(A → C B D | A → C D) > P(b | a) · P(c | b) · P(d | c) · P(A → C B D | A → C B D) · P(B → Q R | B → Q R) · P(Q → Z | Q → Z) Training Corpus In order to train our system, we used the Ziﬀ-Davis corpus, a collection of newspaper articles announcing computer products. Many of the articles in the corpus are paired with human written abstracts. We automat- ically extracted from the corpus a set of 1067 sentence pairs. Each pair consisted of a sentence t = t1, t2, . . . , tn that occurred in the article and a possibly compressed version of it s = s1, s2, . . . , sm, which occurred in the human written abstract. Figure 2 shows a few sentence pairs extracted from the corpus. We decided to use such a corpus because it is con- sistent with two desiderata speciﬁc to summarization work: (i) the human-written Abstract sentences are grammatical; (ii) the Abstract sentences represent in a compressed form the salient points of the original news- paper Sentences. We decided to keep in the corpus un- compressed sentences as well, since we want to learn not only how to compress a sentence, but also when to do it. Learning Model Parameters We collect expansion-template probabilities from our parallel corpus. We ﬁrst parse both sides of the parallel corpus, and then we identify corresponding syntactic nodes. For example, the parse tree for one sentence may begin (S (NP . . . ) (VP . . . ) (PP . . . )) while the parse tree for its compressed version may begin (S (NP . . . ) (VP . . . )). If these two S nodes are deemed to correspond, then we chalk up one joint event (S → NP VP, S → NP VP PP); afterwards we normalize. Not all nodes have corresponding partners; some non- correspondences are due to incorrect parses, while oth- ers are due to legitimate reformulations that are beyond the scope of our simple channel model. We use standard methods to estimate word-bigram probabilities. Decoding There is a vast number of potential compressions of a large tree t, but we can pack them all eﬃciently into a shared-forest structure. For each node of t that has n children, we • generate 2n − 1 new nodes, one for each non-empty subset of the children, and • pack those nodes so that they are referred to as a whole. For example, consider the large tree t above. All com- pressions can be represented with the following forest: G → H A B → R A → B C H → a G → H Q → Z A → C C → b G → A A → C B D A → B Z → c B → Q R A → C B A → D R → d B → Q A → C D D → e We can also assign an expansion-template probability to each node in the forest. For example, to the B → Q node, we can assign P(B → Q R | B → Q). If the observed probability from the parallel corpus is zero, then we assign a small ﬂoor value of 10−6 . In reality, we produce forests that are much slimmer, as we only consider compressing a node in ways that are locally grammatical according to the Penn Treebank—if a rule of the type A → C B has never been observed, then it will not appear in the forest. At this point, we want to extract a set of high- scoring trees from the forest, taking into account both expansion-template probabilities and word-bigram probabilities. Fortunately, we have such a generic ex- tractor on hand (Langkilde 2000). This extractor was designed for a hybrid symbolic-statistical natural lan- guage generation system called Nitrogen. In that ap- plication, a rule-based component converts an abstract semantic representation into a vast number of potential English renderings. These renderings are packed into a forest, from which the most promising sentences are extracted using statistical scoring. For our purposes, the extractor selects the trees with the best combination of word-bigram and expansion- template scores. It returns a list of such trees, one for each possible compression length. For example, for the sentence Beyond that basic level, the operations of the three products vary, we obtain the following “best” compressions, with negative log-probabilities shown in parentheses (smaller = more likely): Beyond that basic level, the operations of the three products vary widely (1514588) Beyond that level, the operations of the three products vary widely (1430374) Beyond that basic level, the operations of the three products vary (1333437) Beyond that level, the operations of the three products vary (1249223) Beyond that basic level, the operations of the products vary (1181377) The operations of the three products vary widely (939912) The operations of the products vary widely (872066) The operations of the products vary (748761) The operations of products vary (690915) Operations of products vary (809158) The operations vary (522402) Operations vary (662642) Length Selection It is useful to have multiple answers to choose from, as one user may seek a 20% compression, while another seeks a 60% compression. However, for purposes of evaluation, we want our system to be able to select a single compression. If we rely on the log-probabilities as shown above, we will almost always choose the short- est compression. (Note above, however, how the three- word compression scores better than the two-word com- pression, as the models are not entirely happy removing the article “the”). To create a more fair competition, we divide the log-probability by the length of the com- pression, rewarding longer strings. This is commonly done in speech recognition. If we plot this normalized score against compression length, we usually observe a (bumpy) U-shaped curve, as illustrated in Figure 3. In a typical more diﬃcult case, a 25-word sentence may be optimally compressed by a 17-word version. Of course, if a user requires a shorter compression than that, she may select another region of the curve and look for a local minimum. A decision-based model for sentence compression In this section, we describe a decision-based, history model of sentence compression. As in the noisy-channel approach, we again assume that we are given as input Finally another advantage of broadband is distance . Finally, another advantage of broadband is distance . Another advantage of broadband is distance . Advantage of broadband is distance . Another advantage is distance . Advantage is distance . 4 6 5 7 8 9 0.20 0.15 0.10 compression s at a particular length n Adjusted negative log-probability of best -log P(s) P( t | s) / n Compression length n Figure 3: Adjusted log-probabilities for top-scoring compressions at various lengths (lower is better). a parse tree t. Our goal is to “rewrite” t into a smaller tree s, which corresponds to a compressed version of the original sentence subsumed by t. Suppose we observe in our corpus the trees t and s2 in Figure 1. In this model, we ask ourselves how we may go about rewriting t into 

la conclusion est : (null)

ReferencesBarzilay, R.; McKeown, K.; and Elhadad, M. 1999.Information fusion in the context of multi-documentsummarization. In Proceedings of the 37th AnnualMeeting of the Association for Computational Linguistics (ACL–99), 550–557.Berger, A., and Laﬀerty, J. 1999. Information retrievalas statistical translation. In Proceedings of the 22ndConference on Research and Development in Information Retrieval (SIGIR–99), 222–229.Brown, P.; Della Pietra, S.; Della Pietra, V.; and Mercer, R. 1993. The mathematics of statistical machine translation: Parameter estimation. Computational Linguistics 19(2):263–311.Church, K. 1988. A stochastic parts program and nounphrase parser for unrestricted text. In Proceedings ofthe Second Conference on Applied Natural LanguageProcessing, 136–143.Collins, M. 1997. Three generative, lexicalized models for statistical parsing. In Proceedings of the 35thAnnual Meeting of the Association for ComputationalLinguistics (ACL–97), 16–23.Grefenstette, G. 1998. Producing intelligent telegraphic text reduction to provide an audio scanningservice for the blind. In Working Notes of the AAAISpring Symposium on Intelligent Text Summarization,111–118.Jelinek, F. 1997. Statistical Methods for Speech Recognition. The MIT Press.Jing, H., and McKeown, K. 1999. The decompositionof human-written summary sentences. In Proceedingsof the 22nd Conference on Research and Developmentin Information Retrieval (SIGIR–99).Knight, K., and Graehl, J. 1998. Machine transliteration. Computational Linguistics 24(4):599–612.Langkilde, I. 2000. Forest-based statistical sentencegeneration. In Proceedings of the 1st Annual Meetingof the North American Chapter of the Association forComputational Linguistics.Linke-Ellis, N. 1999. Closed captioning in America: Looking beyond compliance. In Proceedings ofthe TAO Workshop on TV Closed Captions for thehearing impaired people, 43–59.Magerman, D. 1995. Statistical decision-tree modelsfor parsing. In Proceedings of the 33rd Annual Meetingof the Association for Computational Linguistics, 276–283.Mani, I., and Maybury, M., eds. 1999. Advances inAutomatic Text Summarization. The MIT Press.Mani, I.; Gates, B.; and Bloedorn, E. 1999. Improvingsummaries by revising them. In Proceedings of the 37thAnnual Meeting of the Association for ComputationalLinguistics, 558–565.McKeown, K.; Klavans, J.; Hatzivassiloglou, V.;Barzilay, R.; and Eskin, E. 1999. Towards multidocument summarization by reformulation: Progress andprospects. In Proceedings of the Sixteenth NationalConference on Artiﬁcial Intelligence (AAAI–99).Quinlan, J. 1993. C4.5: Programs for Machine Learning. San Mateo, CA: Morgan Kaufmann Publishers.Robert-Ribes, J.; Pfeiﬀer, S.; Ellison, R.; and Burnham, D. 1999. Semi-automatic captioning of TV programs, an Australian perspective. In Proceedings ofthe TAO Workshop on TV Closed Captions for thehearing impaired people, 87–100.Witbrock, M., and Mittal, V.1999.Ultrasummarization: A statistical approach to generatinghighly condensed non-extractive summaries. In Proceedings of the 22nd International Conference on Research and Development in Information Retrieval (SIGIR’99), Poster Session, 315–316.

